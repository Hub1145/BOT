from flask import Flask, render_template, request, jsonify, send_file, session, redirect, url_for
from flask_socketio import SocketIO, emit
from functools import wraps
import json
import logging
import os
import threading
from bot_engine import TradingBotEngine

logging.basicConfig(
    level=logging.DEBUG
)

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key-change-in-production')
socketio = SocketIO(app, 
                   cors_allowed_origins="*", 
                   async_mode='threading',
                   max_http_buffer_size=10000000, # 10MB to handle large daily_reports/trades payload
                   ping_timeout=60, 
                   ping_interval=25)

config_file = 'config.json'
bot_engine = None

def load_config():
    with open(config_file, 'r') as f:
        return json.load(f)

def save_config(config):
    with open(config_file, 'w') as f:
        json.dump(config, f, indent=2)

def emit_to_client(event, data):
    socketio.emit(event, data)

@app.route('/favicon.ico')
def favicon():
    return app.send_static_file('favicon.ico')


def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        config = load_config()
        # If no credentials set, allow entry (to avoid lockouts)
        if not config.get('dashboard_username') or not config.get('dashboard_password'):
            return f(*args, **kwargs)
        
        if not session.get('logged_in'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    config = load_config()
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username == config.get('dashboard_username') and password == config.get('dashboard_password'):
            session['logged_in'] = True
            return redirect(url_for('index'))
        else:
            return "Invalid credentials", 401
            
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    return redirect(url_for('login'))

@app.route('/')
@login_required
def index():
    return render_template('dashboard.html')

@app.route('/api/config', methods=['GET'])
@login_required
def get_config():
    config = load_config()
    return jsonify(config)

@app.route('/api/config', methods=['POST'])
@login_required
def update_config():
    global bot_engine

    try:
        new_config = request.json
        current_config = load_config()

        # Whitelist of all valid parameters
        allowed_params = [
            'okx_api_key', 'okx_api_secret', 'okx_passphrase', 'okx_demo_api_key', 'okx_demo_api_secret', 'okx_demo_api_passphrase',
            'dev_api_key', 'dev_api_secret', 'dev_passphrase', 'dev_demo_api_key', 'dev_demo_api_secret', 'dev_demo_api_passphrase',
            'use_developer_api', 'use_testnet', 'symbol',
            'short_safety_line_price', 'long_safety_line_price', 'leverage', 'max_allowed_used',
            'entry_price_offset', 'batch_offset', 'tp_price_offset', 'sl_price_offset',
            'loop_time_seconds', 'rate_divisor', 'batch_size_per_loop', 'min_order_amount',
            'target_order_amount', 'cancel_unfilled_seconds', 'cancel_on_tp_price_below_market',
            'cancel_on_entry_price_below_market', 'cancel_on_tp_price_above_market',
            'cancel_on_entry_price_above_market', 'direction', 'mode', 'tp_amount', 'sl_amount',
            'trigger_price', 'tp_mode', 'tp_type', 'use_chg_open_close', 'min_chg_open_close',
            'max_chg_open_close', 'use_chg_high_low', 'min_chg_high_low', 'max_chg_high_low',
            'use_chg_high_close', 'min_chg_high_close', 'max_chg_high_close', 'candlestick_timeframe',
            'use_candlestick_conditions', 'log_level', 'use_pnl_auto_cancel', 'pnl_auto_cancel_threshold', 'okx_pos_mode', 'trade_fee_percentage',
            'use_pnl_auto_manual', 'pnl_auto_manual_threshold', 'use_pnl_auto_cal', 'pnl_auto_cal_times',
            'use_pnl_auto_cal_loss', 'pnl_auto_cal_loss_times',
            'use_auto_margin', 'auto_margin_offset',
            'use_size_auto_cal', 'size_auto_cal_times', 'use_size_auto_cal_loss', 'size_auto_cal_loss_times',
            'use_add_pos_auto_cal', 'add_pos_recovery_percent', 'add_pos_profit_multiplier',
            'add_pos_gap_threshold', 'add_pos_size_pct', 'add_pos_max_count', 'add_pos_step2_offset',
            'use_add_pos_above_zero', 'use_add_pos_profit_target',
            'dashboard_username', 'dashboard_password', 'add_pos_gap_threshold_2', 'add_pos_size_pct_2'
        ]

        # Update current_config with only allowed and present keys from new_config
        updates_made = False
        for key, value in new_config.items():
            if key in allowed_params:
                # Type conversion safety could be added here if needed, but JSON usually handles it well enough for basic types
                if current_config.get(key) != value:
                    current_config[key] = value
                    updates_made = True

        if bot_engine and bot_engine.is_running:
             # Relaxed restrictions: Let the engine handle sensitive swaps dynamically
             # We only block things that absolutely cannot be changed (none currently identified as engine handles them)
             pass
        
        if updates_made:
            save_config(current_config)

            warning_msg = None
            if bot_engine and bot_engine.is_running:
                # Update the bot's internal config object and trigger dynamic updates
                result = bot_engine.apply_live_config_update(current_config)
                if result.get('warnings'):
                    warning_msg = " | ".join(result['warnings'])
                bot_engine.log("Configuration updated live from dashboard.", level="info")
            elif bot_engine:
                 # If not running, just sync the config object
                 bot_engine.config = current_config

            def background_init():
                global bot_engine
                # Ensure bot engine exists
                if not bot_engine:
                    bot_engine = TradingBotEngine(config_file, emit_to_client)

                # If not trading, we still refresh credentials for background monitoring
                if not bot_engine.is_running:
                    bot_engine.start(passive_monitoring=True)
                else:
                    # If already running, we might need to apply new credentials if they changed
                    # (Though credentials are usually considered sensitive and blocked if changed while running)
                    bot_engine._apply_api_credentials()
                
                # Check if the currently selected credentials are valid
                valid, msg = bot_engine.check_credentials()
                if not valid:
                    emit_to_client('error', {'message': f'API Credentials Error: {msg}'})
            
            threading.Thread(target=background_init, daemon=True).start()
            
            final_msg = 'Configuration updated successfully'
            if warning_msg:
                final_msg += f" (Note: {warning_msg})"
            
            return jsonify({'success': True, 'message': final_msg})
        else:
            return jsonify({'success': True, 'message': 'No changes detected'})

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/shutdown', methods=['POST'])
@login_required
def shutdown():
    global bot_engine
    if bot_engine:
        bot_engine.stop_bot()
    
    # Save config before shutdown
    config = load_config()
    save_config(config)
    
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        return jsonify({'success': False, 'message': 'Not running with the Werkzeug Server'})
    
    func()
    return jsonify({'success': True, 'message': 'Server shutting down...'})

@app.route('/api/download_logs')
@login_required
def download_logs():
    try:
        log_file = 'info.log'
        if not os.path.exists(log_file):
             # Fallback to debug.log if info.log not yet created
             log_file = 'debug.log'
             if not os.path.exists(log_file):
                 return jsonify({'error': 'Log file not found'}), 404
        
        # Flush handlers to ensure latest logs are written
        for handler in logging.getLogger().handlers:
            if hasattr(handler, 'flush'):
                handler.flush()
            
        return send_file(
            log_file,
            mimetype='text/plain',
            as_attachment=True,
            download_name='bot_info.log'
        )
    except Exception as e:
        logging.error(f'Error downloading logs: {str(e)}', exc_info=True)
        return jsonify({'error': str(e)}), 500

@app.route('/api/test_api_key', methods=['POST'])
@login_required
def test_api_key_route():
    try:
        data = request.json
        api_key = data.get('api_key')
        api_secret = data.get('api_secret')
        passphrase = data.get('passphrase')
        use_testnet = data.get('use_testnet')

        if not all([api_key, api_secret, passphrase]):
            return jsonify({'success': False, 'message': 'All API credentials (Key, Secret, Passphrase) are required.'}), 400

        # Temporarily create a bot_engine instance to test credentials
        # This bypasses the global bot_engine state
        temp_bot_engine = TradingBotEngine(config_file, emit_to_client)
        temp_bot_engine.config['okx_api_key'] = api_key
        temp_bot_engine.config['okx_api_secret'] = api_secret
        temp_bot_engine.config['okx_passphrase'] = passphrase
        temp_bot_engine.config['okx_demo_api_key'] = api_key # Also set for demo if testnet is used
        temp_bot_engine.config['okx_demo_api_secret'] = api_secret
        temp_bot_engine.config['okx_demo_api_passphrase'] = passphrase
        temp_bot_engine.config['use_testnet'] = use_testnet
        
        # Re-initialize global API credentials for the temp bot engine based on the provided data
        if use_testnet:
            temp_bot_engine.config['okx_api_key'] = temp_bot_engine.config['okx_demo_api_key']
            temp_bot_engine.config['okx_api_secret'] = temp_bot_engine.config['okx_demo_api_secret']
            temp_bot_engine.config['okx_passphrase'] = temp_bot_engine.config['okx_demo_api_passphrase']
            temp_bot_engine.okx_simulated_trading_header = {'x-simulated-trading': '1'}
        else:
            temp_bot_engine.okx_simulated_trading_header = {}

        if temp_bot_engine.test_api_credentials():
            return jsonify({'success': True, 'message': 'API credentials are valid.'})
        else:
            return jsonify({'success': False, 'message': 'Invalid API credentials or connection error.'}), 401

    except Exception as e:
        logging.error(f'Error testing API key: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'message': f'An unexpected error occurred: {str(e)}'}), 500


@app.route('/api/status', methods=['GET'])
@login_required
def get_status():
    global bot_engine
    if not bot_engine:
        try:
            bot_engine = TradingBotEngine(config_file, emit_to_client)
            # Start background monitoring automatically
            bot_engine.start(passive_monitoring=True)
        except Exception as e:
            logging.error(f"Error initializing bot engine for status: {e}")
            return jsonify({'running': False, 'error': str(e)}), 500

    # Trigger a sync if not running to get fresh data for dashboard
    if not bot_engine.is_running:
        try:
            bot_engine.fetch_account_data_sync()
        except Exception as e:
            logging.error(f"Error fetching sync account data: {e}")

    # Calculate trades and fees for emission
    total_active_trades_count = bot_engine.total_trades_count + len(bot_engine.open_trades)
    # Calculate trades and fees for emission
    total_active_trades_count = bot_engine.total_trades_count + len(bot_engine.open_trades)
    # trade_fees is already calculated in bot_engine, use it directly to ensure consistency
    
    # helper for targets
    trade_fee_pct = bot_engine.config.get('trade_fee_percentage', 0.08) / 100.0
    okx_pos_notional = getattr(bot_engine, 'cached_pos_notional', 0.0)
    current_size_fee = okx_pos_notional * trade_fee_pct if okx_pos_notional > 0 else 0.0

    return jsonify({
        'running': bot_engine.is_running,
        'total_balance': bot_engine.account_balance,
        'open_trades': bot_engine.open_trades,
        'net_profit': bot_engine.net_profit,
        'total_trades': total_active_trades_count,
        'total_trades': total_active_trades_count,
        'trade_fees': getattr(bot_engine, 'trade_fees', 0.0),
        'total_capital': bot_engine.total_equity,
        'used_amount': bot_engine.used_amount_notional,
        'remaining_amount': bot_engine.remaining_amount_notional,
        'max_allowed_used_display': bot_engine.max_allowed_display,
        'max_amount_display': bot_engine.max_amount_display,
        'in_position': bot_engine.in_position,
        'position_entry_price': bot_engine.position_entry_price,
        'position_qty': bot_engine.position_qty,
        'current_take_profit': bot_engine.current_take_profit,
        'current_stop_loss': bot_engine.current_stop_loss,
        # Standardize for the frontend if it expects dual positions
        'positions': {
            'long': {
                'in': bot_engine.in_position.get('long', False),
                'qty': bot_engine.position_qty.get('long', 0.0),
                'price': bot_engine.position_entry_price.get('long', 0.0)
            },
            'short': {
                'in': bot_engine.in_position.get('short', False),
                'qty': bot_engine.position_qty.get('short', 0.0),
                'price': bot_engine.position_entry_price.get('short', 0.0)
            }
        },
        'primary_in_position': any(bot_engine.in_position.values()),
        'total_capital_2nd': bot_engine.total_capital_2nd,
        'size_amount': bot_engine.used_amount_notional,
        'need_add_usdt': getattr(bot_engine, 'need_add_usdt_profit_target', 0.0),
        'need_add_above_zero': getattr(bot_engine, 'need_add_usdt_above_zero', 0.0),
        # Realized profit tracking
        'net_trade_profit': getattr(bot_engine, 'net_trade_profit', 0.0),
        'total_trade_profit': getattr(bot_engine, 'total_trade_profit', 0.0),
        'total_trade_profit': getattr(bot_engine, 'total_trade_profit', 0.0),
        'total_trade_loss': getattr(bot_engine, 'total_trade_loss', 0.0),
        
        # Real-time calculated targets (Match socket 'account_update')
        'auto_cal_profit_target': bot_engine.config.get('pnl_auto_cal_times', 4) * current_size_fee,
        'auto_cal_loss_target': -bot_engine.config.get('pnl_auto_cal_loss_times', 1.5) * current_size_fee,
        'size_profit_target': bot_engine.config.get('size_auto_cal_times', 2.0) * current_size_fee,
        'size_loss_target': -bot_engine.config.get('size_auto_cal_loss_times', 1.5) * current_size_fee,
        'mode_2_profit_target': bot_engine.config.get('add_pos_profit_multiplier', 1.5) * current_size_fee
    })
 
@socketio.on('connect')
def handle_connect(auth=None): # changed sid to auth/none as sid is in request.sid
    global bot_engine
    sid = getattr(request, 'sid', None)
    logging.info(f'Client connected: {sid}')
    
    if not sid:
        return False # Reject connection if no sid found

    emit('connection_status', {'connected': True}, room=sid)
 
    if not bot_engine:
        try:
            bot_engine = TradingBotEngine(config_file, emit_to_client)
            bot_engine.start(passive_monitoring=True)
        except Exception as e:
            logging.error(f"Error auto-initializing bot engine on connect: {e}")

    if bot_engine:
        emit('bot_status', {'running': bot_engine.is_running}, room=sid)
        
        # Trigger a sync to ensure metrics are fresh for this client
        # Use a thread so we don't block the connection handshake
        def initial_sync():
            bot_engine.fetch_account_data_sync()
            
            # Emit fresh data once fetched
            payload = {
                'total_capital': bot_engine.total_equity,
                'total_capital_2nd': bot_engine.total_capital_2nd,
                'max_allowed_used_display': bot_engine.max_allowed_display,
                'max_amount_display': bot_engine.max_amount_display,
                'used_amount': bot_engine.used_amount_notional,
                'size_amount': getattr(bot_engine, 'cached_pos_notional', 0.0),
                'trade_fees': bot_engine.trade_fees,
                'used_fees': getattr(bot_engine, 'used_fees', 0.0),
                'size_fees': getattr(bot_engine, 'size_fees', 0.0),
                'remaining_amount': bot_engine.remaining_amount_notional,
                'total_balance': bot_engine.account_balance,
                'available_balance': bot_engine.available_balance,
                'net_profit': bot_engine.net_profit,
                'total_trades': len(bot_engine.open_trades) + bot_engine.total_trades_count,
                'net_trade_profit': bot_engine.net_trade_profit,
                'total_trade_profit': bot_engine.total_trade_profit,
                'total_trade_loss': bot_engine.total_trade_loss
            }
            socketio.emit('account_update', payload, room=sid)
            socketio.emit('trades_update', {'trades': bot_engine.open_trades}, room=sid)
            socketio.emit('position_update', {
                'in_position': bot_engine.in_position,
                'position_entry_price': bot_engine.position_entry_price,
                'position_qty': bot_engine.position_qty,
                'current_take_profit': bot_engine.current_take_profit,
                'current_stop_loss': bot_engine.current_stop_loss
            }, room=sid)
            
            for log in list(bot_engine.console_logs):
                socketio.emit('console_log', log, room=sid)

        threading.Thread(target=initial_sync, daemon=True).start()

@socketio.on('disconnect')
def handle_disconnect():
    logging.info('Client disconnected')

@socketio.on('start_bot')
def handle_start_bot(data=None):
    global bot_engine

    try:
        if bot_engine and bot_engine.is_running:
            emit('error', {'message': 'Bot is already running'})
            return

        if not bot_engine:
             bot_engine = TradingBotEngine(config_file, emit_to_client)

        # 1. Check Credentials before starting
        valid, msg = bot_engine.check_credentials()
        if not valid:
            emit('error', {'message': f'API Credentials Error: {msg}'})
            return

        try:
            bot_engine.start()
            if bot_engine.is_running:
                socketio.emit('bot_status', {'running': True}) # Broadcast status to all
                emit('success', {'message': 'Bot started successfully'})
            else:
                # If bot_engine.start() returned False internally (e.g. position mode error),
                # it already emitted its own error log and 'bot_status': False.
                # However, we'll re-sync just in case.
                socketio.emit('bot_status', {'running': False})
        except Exception as e:
            logging.error(f'Error during bot_engine instantiation or start: {str(e)}', exc_info=True)
            emit('error', {'message': f'Failed to start bot: {str(e)}'})
    except Exception as e: # Catch errors from load_config()
        logging.error(f'Error loading configuration in handle_start_bot: {str(e)}', exc_info=True)
        emit('error', {'message': f'Failed to start bot due to config error: {str(e)}'})

@socketio.on('stop_bot')
def handle_stop_bot(data=None):
    global bot_engine

    try:
        if not bot_engine or not bot_engine.is_running:
            emit('error', {'message': 'Bot is not running'})
            return

        bot_engine.stop()
        socketio.emit('bot_status', {'running': False}) # Broadcast status to all
        emit('success', {'message': 'Bot stopped successfully'})

    except Exception as e:
        logging.error(f'Error stopping bot: {str(e)}')
        emit('error', {'message': f'Failed to stop bot: {str(e)}'})

@socketio.on('clear_console')
def handle_clear_console(data=None):
    if bot_engine:
        bot_engine.console_logs.clear()
    emit('console_cleared', {})

@socketio.on('batch_modify_tpsl')
def handle_batch_modify_tpsl(data=None):
    global bot_engine
    if not bot_engine:
         bot_engine = TradingBotEngine(config_file, emit_to_client)
         bot_engine.start(passive_monitoring=True)
    
    bot_engine.batch_modify_tpsl()

@socketio.on('batch_cancel_orders')
def handle_batch_cancel_orders(data=None):
    global bot_engine
    if not bot_engine:
         bot_engine = TradingBotEngine(config_file, emit_to_client)
         bot_engine.start(passive_monitoring=True)
    
    bot_engine.batch_cancel_orders()

@socketio.on('emergency_sl')
def handle_emergency_sl(data=None):
    global bot_engine
    if not bot_engine:
         bot_engine = TradingBotEngine(config_file, emit_to_client)
         bot_engine.start(passive_monitoring=True)
    
    bot_engine.emergency_sl()


if __name__ == '__main__':
    # Initialize and start in passive monitoring mode on startup
    # This allows Auto-Cal features to run even before user clicks "Start"
    if not bot_engine:
        bot_engine = TradingBotEngine(config_file, emit_to_client)
        bot_engine.start(passive_monitoring=True)
        
    socketio.run(app, host='0.0.0.0', port=5000, debug=False, use_reloader=False, log_output=True, allow_unsafe_werkzeug=True)
